spring:
  cache:
    type: redis
  datasource:
    # 生产环境通常连接 Docker 容器名或云数据库地址
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:exam_system}?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai&useSSL=false&allowPublicKeyRetrieval=true&cachePrepStmts=true&prepStmtCacheSize=250&prepStmtCacheSqlLimit=2048&useServerPrepStmts=true&rewriteBatchedStatements=true
    # 【核心】强制从环境变量获取，如果没有设置则报错或使用空
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

    # HikariCP 连接池优化配置（生产环境）
    hikari:
      # 连接池名称，便于监控识别
      pool-name: ExeSystemHikariCP-Prod
      # 最小空闲连接数（生产环境保持较高值以应对突发流量）
      minimum-idle: 10
      # 最大连接池大小（根据数据库最大连接数和应用实例数调整）
      # 公式：max-active = ((core_count * 2) + effective_spindle_count)
      # 对于典型应用，推荐值：CPU核心数 * 2 + 1，这里设置为 50
      maximum-pool-size: 50
      # 连接超时时间（毫秒）- 从池中获取连接的最大等待时间
      connection-timeout: 20000
      # 空闲连接超时时间（毫秒）- 10分钟，超过此时间的空闲连接会被释放
      idle-timeout: 600000
      # 连接最大存活时间（毫秒）- 30分钟，防止数据库主动断开长时间存活的连接
      max-lifetime: 1800000
      # 连接测试查询（HikariCP 推荐不设置，使用 JDBC4 的 isValid() 方法）
      # connection-test-query: SELECT 1
      # 自动提交
      auto-commit: true
      # 连接初始化 SQL
      connection-init-sql: SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci
      # 泄漏检测阈值（毫秒）- 生产环境设置较短时间以快速发现连接泄漏问题
      leak-detection-threshold: 30000
      # 验证超时时间（毫秒）- 连接有效性检测的超时时间
      validation-timeout: 5000
      # 初始化失败快速失败
      initialization-fail-timeout: 1
      # 只读模式（如果需要读写分离可以设置）
      read-only: false
      # 注册 JMX MBeans（启用 JMX 监控）
      register-mbeans: true
  data:
    redis:
      # Redis 地址也应该可配
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD} # 如果 Redis 有密码
      lettuce:
        pool:
          max-active: 100
          max-idle: 20
          min-idle: 5

jwt:
  # 【核心】生产环境必须注入高强度密钥
  secret: ${JWT_SECRET}
  expiration: 86400000